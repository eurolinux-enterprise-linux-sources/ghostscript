From: Chris Liddell <chris.liddell@artifex.com>
Date: Fri, 24 Aug 2018 08:26:04 +0000 (+0100)
Subject: Improve restore robustness

Improve restore robustness

Prompted by looking at Bug 699654:

There are two variants of the restore operator in Ghostscript: one is Level 1
(restoring VM), the other is Level 2+ (adding page device restoring to the
Level operator).

This was implemented by the Level 2+ version restoring the device in the
graphics state, then calling the Level 1 implementation to handle actually
restoring the VM state.

The problem was that the operand checking, and sanity of the save object was
only done by the Level 1 variant, thus meaning an invalid save object could
leave a (Level 2+) restore partially complete - with the page device part
restored, but not VM, and the page device not configured.

To solve that, this commit splits the operand and sanity checking, and the
core of the restore operation into separate functions, so the relevant
operators can validate the operand *before* taking any further action. That
reduces the chances of an invalid restore leaving the interpreter in an
unknown state.

If an error occurs during the actual VM restore it is essentially fatal, and the
interpreter cannot continue, but as an extra surety for security, in the event
of such an error, we'll explicitly preserve the LockSafetyParams of the device,
rather than rely on the post-restore device configuration (which won't happen
in the event of an error).

https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=5516c614dc33662a2afdc377159f70218e67bde5

From: Chris Liddell <chris.liddell@artifex.com>
Date: Sat, 25 Aug 2018 06:45:45 +0000 (+0100)
Subject: Bug 699654(2): preserve LockSafetyParams in the nulldevice

Bug 699654(2): preserve LockSafetyParams in the nulldevice

The nulldevice does not necessarily use the normal setpagedevice machinery,
but can be set using the nulldevice operator. In which case, we don't preserve
the settings from the original device (in the way setpagedevice does).

Since nulldevice does nothing, this is not generally a problem, but in the case
of LockSafetyParams it *is* important when we restore back to the original
device, when LockSafetyParams not being set is "preserved" into the post-
restore configuration.

We have to initialise the value to false because the nulldevice is used during
initialisation (before any other device exists), and *must* be writable for
that.

http://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=79cccf641486a6595c43f1de1cd7ade696020a31

From: Ken Sharp <ken.sharp@artifex.com>
Date: Tue, 28 Aug 2018 15:27:53 +0000 (+0100)
Subject: Bug #699654 (again) and Bug #699677 Improve operator removal for SAFER

Bug #699654 (again) and Bug #699677 Improve operator removal for SAFER

Take inspiration from the code to remove unused/dangerous operators
and, when SAFER is true, remove a bunch more non-standard operators
or routines.

In particular remove the .bindnow operator, which should have been
removed previously for Bug #699677 and remove the
.pushpdf14devicefilter for Bug #699654. Only the PDF interpreter
needs to use that, and the device in question only expects to be used
carefully and in the correct sequence. Make sure nobody can meddle with
it.

In addition I removed a number of other operators which are not needed
in normal operation. Some of them, however, are useful so these
(with the exception of .bindnow which is always removed) are only
undefined if SAFER is true.

This allows our QA procedure to continue to use them, which is
particularly important in the case of .makeoperator and .setCPSImode.

At a later date we may choose to move some of these into the regular
undefinition code, ie not dependent on SAFER.

https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=520bb0ea7519aa3e79db78aaf0589dae02103764
---

diff -up ghostscript-8.70/base/gsdevice.c.cve-2018-16509 ghostscript-8.70/base/gsdevice.c
--- ghostscript-8.70/base/gsdevice.c.cve-2018-16509	2008-03-19 11:09:21.000000000 +0100
+++ ghostscript-8.70/base/gsdevice.c	2018-11-23 15:17:21.234523363 +0100
@@ -517,21 +517,27 @@ gx_device_retain(gx_device *dev, bool re
 int
 gs_nulldevice(gs_state * pgs)
 {
+    int code = 0;
+    bool saveLockSafety = false;
     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
 	gx_device *ndev;
-	int code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
+	code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
 				 pgs->memory);
 
 	if (code < 0)
 	    return code;
+	if (gs_currentdevice_inline(pgs) != NULL)
+	    saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;
 	/*
 	 * Internal devices have a reference count of 0, not 1,
 	 * aside from references from graphics states.
 	 */
 	rc_init(ndev, pgs->memory, 0);
-	return gs_setdevice_no_erase(pgs, ndev);
+	if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
+	    gs_free_object(pgs->memory, ndev, "gs_copydevice(device)");
+	gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;
     }
-    return 0;
+    return code;
 }
 
 /* Close a device.  The client is responsible for ensuring that */
diff -up ghostscript-8.70/psi/int.mak.cve-2018-16509 ghostscript-8.70/psi/int.mak
--- ghostscript-8.70/psi/int.mak.cve-2018-16509	2018-11-23 15:17:21.136525035 +0100
+++ ghostscript-8.70/psi/int.mak	2018-11-23 15:17:21.234523363 +0100
@@ -1041,8 +1041,8 @@ $(PSD)pagedev.dev : $(INT_MAK) $(ECHOGS_
 
 $(PSOBJ)zdevice2.$(OBJ) : $(PSSRC)zdevice2.c $(OP) $(math__h) $(memory__h)\
  $(dstack_h) $(estack_h)\
- $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(iutil_h) $(store_h)\
- $(gxdevice_h) $(gsstate_h)
+ $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(isave) $(iutil_h) \
+ $(store_h) $(gxdevice_h) $(gsstate_h)
 	$(PSCC) $(PSO_)zdevice2.$(OBJ) $(C_) $(PSSRC)zdevice2.c
 
 $(PSOBJ)zmedia2.$(OBJ) : $(PSSRC)zmedia2.c $(OP) $(math__h) $(memory__h)\
diff -up ghostscript-8.70/psi/isave.h.cve-2018-16509 ghostscript-8.70/psi/isave.h
--- ghostscript-8.70/psi/isave.h.cve-2018-16509	2008-08-29 00:48:19.000000000 +0200
+++ ghostscript-8.70/psi/isave.h	2018-11-23 15:17:21.234523363 +0100
@@ -116,4 +116,10 @@ void alloc_set_not_in_save(gs_dual_memor
 /* Remove entries from font and character caches. */
 int  font_restore(const alloc_save_t * save);
 
+int
+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave);
+
+int
+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave);
+
 #endif /* isave_INCLUDED */
diff -up ghostscript-8.70/psi/zdevice2.c.cve-2018-16509 ghostscript-8.70/psi/zdevice2.c
--- ghostscript-8.70/psi/zdevice2.c.cve-2018-16509	2008-08-29 00:48:19.000000000 +0200
+++ ghostscript-8.70/psi/zdevice2.c	2018-11-23 15:17:21.234523363 +0100
@@ -24,6 +24,7 @@
 #include "igstate.h"
 #include "iname.h"
 #include "iutil.h"
+#include "isave.h"
 #include "store.h"
 #include "gxdevice.h"
 #include "gsstate.h"
@@ -304,11 +305,25 @@ z2grestoreall(i_ctx_t *i_ctx_p)
     }
     return 0;
 }
-
+/* This is the Level 2+ variant of restore - which adds restoring
+   of the page device to the Level 1 variant in zvmem.c.
+   Previous this restored the device state before calling zrestore.c
+   which validated operands etc, meaning a restore could error out
+   partially complete.
+   The operand checking, and actual VM restore are now in two functions
+   so they can called separately thus, here, we can do as much
+   checking as possible, before embarking on actual changes
+ */
 /* <save> restore - */
 static int
 z2restore(i_ctx_t *i_ctx_p)
 {
+    alloc_save_t *asave;
+    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;
+    int code = restore_check_save(i_ctx_p, &asave);
+
+    if (code < 0) return code;
+
     while (gs_state_saved(gs_state_saved(igs))) {
 	if (restore_page_device(igs, gs_state_saved(igs)))
 	    return push_callout(i_ctx_p, "%restore1pagedevice");
@@ -316,7 +331,20 @@ z2restore(i_ctx_t *i_ctx_p)
     }
     if (restore_page_device(igs, gs_state_saved(igs)))
 	return push_callout(i_ctx_p, "%restorepagedevice");
-    return zrestore(i_ctx_p);
+
+    code = dorestore(i_ctx_p, asave);
+
+    if (code < 0) {
+        /* An error here is basically fatal, but....
+           restore_page_device() has to set LockSafetyParams false so it can
+           configure the restored device correctly - in normal operation, that
+           gets reset by that configuration. If we hit an error, though, that
+           may not happen -  at least ensure we keep the setting through the
+           error.
+         */
+        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;
+    }
+    return code;
 }
 
 /* <gstate> setgstate - */
diff -up ghostscript-8.70/psi/zvmem.c.cve-2018-16509 ghostscript-8.70/psi/zvmem.c
--- ghostscript-8.70/psi/zvmem.c.cve-2018-16509	2008-08-29 00:48:19.000000000 +0200
+++ ghostscript-8.70/psi/zvmem.c	2018-11-23 15:17:21.235523346 +0100
@@ -102,19 +102,17 @@ zsave(i_ctx_t *i_ctx_p)
 static int restore_check_operand(os_ptr, alloc_save_t **, gs_dual_memory_t *);
 static int restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t *, const alloc_save_t *, bool);
 static void restore_fix_stack(ref_stack_t *, const alloc_save_t *, bool);
+/* Do as many up front checks of the save object as we reasonably can */
 int
-zrestore(i_ctx_t *i_ctx_p)
+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave)
 {
     os_ptr op = osp;
-    alloc_save_t *asave;
-    bool last;
-    vm_save_t *vmsave;
-    int code = restore_check_operand(op, &asave, idmemory);
+    int code = restore_check_operand(op, asave, idmemory);
 
     if (code < 0)
 	return code;
     if_debug2('u', "[u]vmrestore 0x%lx, id = %lu\n",
-	      (ulong) alloc_save_client_data(asave),
+              (ulong) alloc_save_client_data(*asave),
 	      (ulong) op->value.saveid);
     if (I_VALIDATE_BEFORE_RESTORE)
 	ivalidate_clean_spaces(i_ctx_p);
@@ -123,14 +121,38 @@ zrestore(i_ctx_t *i_ctx_p)
     {
 	int code;
 
-	if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||
-	    (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||
-	    (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0
+        if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 ||
+            (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 ||
+            (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0
 	    ) {
 	    osp++;
 	    return code;
 	}
     }
+
+    osp++;
+    return 0;
+}
+
+/* the semantics of restore differ slightly between Level 1 and
+   Level 2 and later - the latter includes restoring the device
+   state (whilst Level 1 didn't have "page devices" as such).
+   Hence we have two restore operators - one here (Level 1)
+   and one in zdevice2.c (Level 2+). For that reason, the
+   operand checking and guts of the restore operation are
+   separated so both implementations can use them to best
+   effect.
+ */
+int
+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave)
+{
+    os_ptr op = osp;
+    bool last;
+    vm_save_t *vmsave;
+    int code;
+
+    osp--;
+
     /* Reset l_new in all stack entries if the new save level is zero. */
     /* Also do some special fixing on the e-stack. */
     restore_fix_stack(&o_stack, asave, false);
@@ -173,9 +195,24 @@ zrestore(i_ctx_t *i_ctx_p)
     /* cause an 'invalidaccess' in setuserparams. Temporarily set     */
     /* LockFilePermissions false until the gs_lev2.ps can do a        */
     /* setuserparams from the restored userparam dictionary.          */
+    /* NOTE: This is safe to do here, since the restore has           */
+    /* successfully completed - this should never come before any     */
+    /* operation that can trigger an error                            */
     i_ctx_p->LockFilePermissions = false;
     return 0;
 }
+
+int
+zrestore(i_ctx_t *i_ctx_p)
+{
+    alloc_save_t *asave;
+    int code = restore_check_save(i_ctx_p, &asave);
+    if (code < 0)
+        return code;
+
+    return dorestore(i_ctx_p, asave);
+}
+
 /* Check the operand of a restore. */
 static int
 restore_check_operand(os_ptr op, alloc_save_t ** pasave,
@@ -196,6 +233,7 @@ restore_check_operand(os_ptr op, alloc_s
     *pasave = asave;
     return 0;
 }
+
 /* Check a stack to make sure all its elements are older than a save. */
 static int
 restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t * pstack,
diff -up ghostscript-8.70/Resource/Init/gs_init.ps.cve-2018-16509 ghostscript-8.70/Resource/Init/gs_init.ps
--- ghostscript-8.70/Resource/Init/gs_init.ps.cve-2018-16509	2018-11-23 15:27:12.788413668 +0100
+++ ghostscript-8.70/Resource/Init/gs_init.ps	2018-11-23 16:47:06.559832689 +0100
@@ -2075,6 +2075,26 @@ readonly def
 % If we are running in SAFER mode, lock things down
 SAFER { .setsafe } if
 
+/SAFERUndefinePostScriptOperators {
+[
+% Used by our own test suite files
+/.pushpdf14devicefilter    % transparency-example.ps
+/.poppdf14devicefilter     % transparency-example.ps
+/.setopacityalpha          % transparency-example.ps
+/.setshapealpha            % transparency-example.ps
+/.endtransparencygroup     % transparency-example.ps
+/.setdotlength             % Bug687720.ps
+/.sort /.setdebug /.mementolistnewblocks /getenv
+
+/.makeoperator /.setCPSImode              % gs_cet.ps, this won't work on cluster with -dSAFER
+
+/unread
+]
+{systemdict exch .forceundef} forall
+
+//systemdict /SAFERUndefinePostScriptOperators .forceundef
+}bind def
+
 % If we delayed binding, make it possible to do it later.
 /.bindnow {
   currentuserparams /IdiomRecognition .knownget {
@@ -2088,6 +2108,9 @@ SAFER { .setsafe } if
   //systemdict /.delaybind {} .forceput	% reclaim the space
   //systemdict /.bindnow .forceundef	% ditto
   put
+  SAFER {
+    //systemdict /SAFERUndefinePostScriptOperators get exec
+  } if
   //systemdict /.forcecopynew .forceundef	% remove temptation
   //systemdict /.forcedef .forceundef		% ditto
   //systemdict /.forceput .forceundef		% ditto
@@ -2189,11 +2212,20 @@ currentdict /.wheredict .undef
 currentdict /.renderingintentdict .undef
 end
 
+%% If we are using DELAYBIND we have to defer the undefinition
+%% until .bindnow.
+DELAYBIND not {
+  SAFER {
+    //systemdict /SAFERUndefinePostScriptOperators get exec
+  } if
+} if
+
 % Clean up VM, and enable GC.
 /vmreclaim where
  { pop NOGC not { 2 vmreclaim 0 vmreclaim } if
  } if
 DELAYBIND not {
+  systemdict /.bindnow .undef       % We only need this for DELAYBIND
   systemdict /.forcecopynew .undef	% remove temptation
   systemdict /.forcedef .undef		% ditto
   systemdict /.forceput .undef		% ditto
